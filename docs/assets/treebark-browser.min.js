(function(u,b){typeof exports=="object"&&typeof module<"u"?b(exports):typeof define=="function"&&define.amd?define(["exports"],b):(u=typeof globalThis<"u"?globalThis:u||self,b(u.Treebark={}))})(this,(function(u){"use strict";const b=new Set(["div","span","p","header","footer","main","section","article","h1","h2","h3","h4","h5","h6","strong","em","blockquote","code","pre","ul","ol","li","table","thead","tbody","tr","th","td","a"]),P=new Set(["comment","if"]),w=new Set(["img"]),W=new Set([...b,...P,...w]),E=new Set(["id","class","style","title","role","data-","aria-"]),G={a:new Set(["href","target","rel"]),img:new Set(["src","alt","width","height"]),table:new Set(["summary"]),th:new Set(["scope","colspan","rowspan"]),td:new Set(["scope","colspan","rowspan"]),blockquote:new Set(["cite"])};function p(t,n,e=[]){if(n===".")return t;let i=t,r=n;for(;r.startsWith("..");){let o=0,s=r;for(;s.startsWith("..");)o++,s=s.substring(2),s.startsWith("/")&&(s=s.substring(1));if(o<=e.length)i=e[e.length-o],r=s.startsWith(".")?s.substring(1):s;else return}return r?r.split(".").reduce((o,s)=>o&&typeof o=="object"&&o!==null?o[s]:void 0,i):i}function q(t){return t.replace(/[&<>"']/g,n=>({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"})[n]||n)}function O(t,n,e=!0,i=[]){return t.replace(/\{\{\{([^{]*?)\}\}\}|\{\{([^{]*?)\}\}/g,(r,o,s)=>{if(o!==void 0)return`{{${o.trim()}}}`;const l=s.trim(),c=p(n,l,i);return c==null?"":e?q(String(c)):String(c)})}function L(t,n){const e=E.has(t)||[...E].some(o=>o.endsWith("-")&&t.startsWith(o)),i=G[n],r=i&&i.has(t);if(!e&&!r)throw new Error(`Attribute "${t}" is not allowed on tag "${n}"`)}function _(t){return t!==null&&typeof t=="object"&&!Array.isArray(t)&&"$bind"in t}function B(t){return t.$condition??t.$bind}function C(t){if(t!=="."){if(t.includes(".."))throw new Error(`$bind does not support parent context access (..) - use interpolation {{..prop}} in content/attributes instead. Invalid: $bind: "${t}"`);if(t.includes("{{"))throw new Error(`$bind does not support interpolation {{...}} - use literal property paths only. Invalid: $bind: "${t}"`)}}function D(t,n){if("$equals"in n&&n.$equals!==void 0){const i=t===n.$equals;return n.$not?!i:i}if("$notEquals"in n&&n.$notEquals!==void 0){const i=t!==n.$notEquals;return n.$not?!i:i}const e=!!t;return n.$not?!e:e}function N(t){if(Array.isArray(t)||typeof t!="object"||t===null)return!1;const n=Object.entries(t);if(n.length===0)return!1;const[,e]=n[0];return!e||typeof e!="object"||Array.isArray(e)?!1:"$bind"in e&&e.$bind==="."}function R(t){if(!t||typeof t!="object")throw new Error("Template object cannot be null, undefined, or non-object");const n=Object.entries(t);if(n.length===0)throw new Error("Template object must have at least one tag");const e=n[0];if(!e)throw new Error("Template object must have at least one tag");const[i,r]=e,o=typeof r=="string"?[r]:Array.isArray(r)?r:r?.$children||[],s=r&&typeof r=="object"&&!Array.isArray(r)?Object.fromEntries(Object.entries(r).filter(([l])=>l!=="$children")):{};return{tag:i,rest:r,children:o,attrs:s}}const k=(t,n)=>{if(!n)return t.length<=1?t[0]?.[1]??"":t.reduce((i,[,r])=>i+r,"");if(t.length===0)return"";if(t.length===1&&!t[0][1].includes("<"))return t[0][1];let e=`
`;for(let i=0;i<t.length;i++)e+=n.repeat(t[i][0])+t[i][1],i<t.length-1&&(e+=`
`);return e+=`
`,e};function F(t,n={}){const e=Array.isArray(t.data)?t.data:{...t.data,...n.data},i=n.indent?{indentStr:typeof n.indent=="number"?" ".repeat(n.indent):typeof n.indent=="string"?n.indent:"  ",level:0}:{};if(!Array.isArray(t.template)&&Array.isArray(t.data)&&!N(t.template)){const r=i.indentStr?`
`:"";return t.data.map(o=>d(t.template,{...o,...n.data},i)).join(r)}return d(t.template,e,i)}function H(t,n,e,i,r,o,s=[]){const l=k(i,r),c=l.startsWith(`
`)&&r?r.repeat(o||0):"";if(t==="comment")return`<!--${l}${c}-->`;const h=`<${t}${M(n,e,t,s)}>`;return w.has(t)?h:`${h}${l}${c}</${t}>`}function d(t,n,e={}){const i=e.parents||[];if(typeof t=="string")return O(t,n,!0,i);if(Array.isArray(t))return t.map(a=>d(a,n,e)).join(e.indentStr?`
`:"");const{tag:r,rest:o,children:s,attrs:l}=R(t);if(!W.has(r))throw new Error(`Tag "${r}" is not allowed`);if(r==="comment"&&e.insideComment)throw new Error("Nested comments are not allowed");if(r==="if"){if(typeof o!="object"||Array.isArray(o))throw new Error('"if" tag requires attributes object');const a=o,f=B(a);if(!f)throw new Error('"if" tag requires $bind or $condition attribute to specify the condition');C(f);const g=p(n,f,i),{$bind:S,$condition:y,$children:$=[],$not:j,$equals:v,$notEquals:z,...J}=a;if(Object.keys(J).length>0)throw new Error('"if" tag does not support attributes, only $bind/$condition, $not, $equals, $notEquals, and $children');if(!D(g,{$not:j,$equals:v,$notEquals:z}))return"";if(!e.indentStr)return $.map(T=>d(T,n,e)).join("");const K=e.level||0,Q=e.indentStr.repeat(K);return $.map((T,U)=>{const I=d(T,n,e);return U===0?I:Q+I}).join(`
`)}if(w.has(r)&&s.length>0)throw new Error(`Tag "${r}" is a void element and cannot have children`);const c={...e,insideComment:r==="comment"||e.insideComment,level:(e.level||0)+1},h=a=>a===""?[]:e.indentStr&&a.includes(`
`)&&!a.includes("<")?a.split(`
`).map(f=>[c.level,f]):[[c.level,a]];let m,A;if(_(o)){C(o.$bind);const a=p(n,o.$bind,[]),{$bind:f,$children:g=[],...S}=o;if(!Array.isArray(a)){const y=a&&typeof a=="object"&&a!==null?a:{},$=[...i,n];return d({[r]:{...S,$children:g}},y,{...e,parents:$})}m=[];for(const y of a){const $=[...i,n];for(const j of g){const v=d(j,y,{...c,parents:$});m.push(...h(v))}}A=S}else{m=[];for(const a of s){const f=d(a,n,{...c,parents:i});m.push(...h(f))}A=l}return H(r,A,n,m,e.indentStr,e.level,i)}function M(t,n,e,i=[]){const r=Object.entries(t).filter(([o])=>(L(o,e),!0)).map(([o,s])=>`${o}="${q(O(String(s),n,!1,i))}"`).join(" ");return r?" "+r:""}u.renderToString=F,Object.defineProperty(u,Symbol.toStringTag,{value:"Module"})}));
//# sourceMappingURL=treebark-browser.min.js.map
