(function(m,y){typeof exports=="object"&&typeof module<"u"?module.exports=y():typeof define=="function"&&define.amd?define(y):(m=typeof globalThis<"u"?globalThis:m||self,m.MarkdownItTreebark=y())})(this,(function(){"use strict";const m=new Set(["div","span","p","header","footer","main","section","article","h1","h2","h3","h4","h5","h6","strong","em","blockquote","code","pre","ul","ol","li","table","thead","tbody","tr","th","td","a"]),y=new Set(["$comment","$if"]),b=new Set(["img","br","hr"]),P=new Set([...m,...y,...b]),E=new Set(["id","class","style","title","role","data-","aria-"]),W={a:new Set(["href","target","rel"]),img:new Set(["src","alt","width","height"]),table:new Set(["summary"]),th:new Set(["scope","colspan","rowspan"]),td:new Set(["scope","colspan","rowspan"]),blockquote:new Set(["cite"])},O=new Set(["$<","$>","$<=","$>=","$=","$in"]),C=new Set(["$check","$then","$else","$not","$join",...O]);function g(e,n,t=[],s){if(n===".")return e;let o=e,i=n;for(;i.startsWith("..");){let r=0,a=i;for(;a.startsWith("..");)r++,a=a.substring(2),a.startsWith("/")&&(a=a.substring(1));if(r<=t.length)o=t[t.length-r],i=a.startsWith(".")?a.substring(1):a;else return}if(i){if(s&&typeof o!="object"&&o!==null&&o!==void 0){s.error(`Cannot access property "${i}" on primitive value of type "${typeof o}"`);return}return i.split(".").reduce((r,a)=>r&&typeof r=="object"&&r!==null?r[a]:void 0,o)}return o}function A(e){return e.replace(/[&<>"']/g,n=>({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"})[n]||n)}function w(e,n,t=!0,s=[],o){return e.replace(/\{\{\{([^{]*?)\}\}\}|\{\{([^{]*?)\}\}/g,(i,r,a)=>{if(r!==void 0)return`{{${r.trim()}}}`;const l=a.trim(),u=g(n,l,s,o);return u==null?"":t?A(String(u)):String(u)})}function N(e,n,t){const s=E.has(e)||[...E].some(r=>r.endsWith("-")&&e.startsWith(r)),o=W[n],i=o&&o.has(e);return!s&&!i?(t.warn(`Attribute "${e}" is not allowed on tag "${n}"`),!1):!0}function G(e){return e!==null&&typeof e=="object"&&!Array.isArray(e)&&"$bind"in e}function T(e,n,t){return e==="."?!0:e.includes("..")?(t.error(`${n} does not support parent context access (..) - use interpolation {{..prop}} in content/attributes instead. Invalid: ${n}: "${e}"`),!1):e.includes("{{")?(t.error(`${n} does not support interpolation {{...}} - use literal property paths only. Invalid: ${n}: "${e}"`),!1):!0}function k(e,n){const t=[];for(const r of O)r in n&&t.push({key:r,value:n[r]});if(t.length===0){const r=!!e;return n.$not?!r:r}const s=t.map(r=>{switch(r.key){case"$<":return typeof e=="number"&&typeof r.value=="number"&&e<r.value;case"$>":return typeof e=="number"&&typeof r.value=="number"&&e>r.value;case"$<=":return typeof e=="number"&&typeof r.value=="number"&&e<=r.value;case"$>=":return typeof e=="number"&&typeof r.value=="number"&&e>=r.value;case"$=":return e===r.value;case"$in":return Array.isArray(r.value)&&r.value.includes(e);default:return!1}}),o=n.$join==="OR";let i;return o?i=s.some(r=>r):i=s.every(r=>r),n.$not?!i:i}function _(e){return e!==null&&typeof e=="object"&&!Array.isArray(e)&&"$check"in e&&typeof e.$check=="string"}function q(e,n,t=[],s){if(!T(e.$check,"$check",s))return"";const o=g(n,e.$check,t);return k(o,e)?e.$then!==void 0?e.$then:"":e.$else!==void 0?e.$else:""}function D(e,n){if(!e||typeof e!="object"){n.error("Template object cannot be null, undefined, or non-object");return}const t=Object.entries(e);if(t.length===0){n.error("Template object must have at least one tag");return}const s=t[0];if(!s){n.error("Template object must have at least one tag");return}const[o,i]=s,r=typeof i=="string"?[i]:Array.isArray(i)?i:i?.$children||[],a=i&&typeof i=="object"&&!Array.isArray(i)?Object.fromEntries(Object.entries(i).filter(([l])=>l!=="$children")):{};return{tag:o,rest:i,children:r,attrs:a}}function M(e,n,t=[],s){const o=e;if(!o.$check)return s.error('"$if" tag requires $check attribute to specify the condition'),{valueToRender:void 0};if(!T(o.$check,"$check",s))return{valueToRender:void 0};const i=g(n,o.$check,t);typeof e=="object"&&e!==null&&!Array.isArray(e)&&"$children"in e&&s.warn('"$if" tag does not support $children, use $then and $else instead');const{$then:r,$else:a}=o;if(r!==void 0&&Array.isArray(r))return s.error('"$if" tag $then must be a string or single element object, not an array'),{valueToRender:void 0};if(a!==void 0&&Array.isArray(a))return s.error('"$if" tag $else must be a string or single element object, not an array'),{valueToRender:void 0};const u=(typeof e=="object"&&e!==null&&!Array.isArray(e)?Object.keys(e):[]).filter(d=>!C.has(d));return u.length>0&&s.warn(`"$if" tag does not support attributes: ${u.join(", ")}. Allowed: ${[...C].join(", ")}`),{valueToRender:k(i,o)?r:a}}const B=(e,n)=>{if(!n)return e.length<=1?e[0]?.[1]??"":e.reduce((s,[,o])=>s+o,"");if(e.length===0)return"";if(e.length===1&&!e[0][1].includes("<"))return e[0][1];let t=`
`;for(let s=0;s<e.length;s++)t+=n.repeat(e[s][0])+e[s][1],s<e.length-1&&(t+=`
`);return t+=`
`,t};function R(e,n={}){const t=e.data,s=n.logger||console,o=n.indent?{indentStr:typeof n.indent=="number"?" ".repeat(n.indent):typeof n.indent=="string"?n.indent:"  ",level:0,logger:s}:{logger:s};return $(e.template,t,o)}function F(e,n,t,s,o,i,r,a=[]){const l=B(s,i),u=l.startsWith(`
`)&&i?i.repeat(r||0):"";if(e==="$comment")return`<!--${l}${u}-->`;const f=`<${e}${Y(n,t,e,a,o)}>`;return b.has(e)?f:`${f}${l}${u}</${e}>`}function $(e,n,t){const s=t.parents||[],o=t.logger;if(typeof e=="string")return w(e,n,!0,s,o);if(Array.isArray(e))return e.map(c=>$(c,n,t)).join(t.indentStr?`
`:"");const i=D(e,o);if(!i)return"";const{tag:r,rest:a,children:l,attrs:u}=i;if(!P.has(r))return o.error(`Tag "${r}" is not allowed`),"";if(r==="$comment"&&t.insideComment)return o.error("Nested comments are not allowed"),"";if(r==="$if"){const{valueToRender:c}=M(a,n,s,o);return c===void 0?"":$(c,n,t)}b.has(r)&&l.length>0&&o.warn(`Tag "${r}" is a void element and cannot have children`);const f={...t,insideComment:r==="$comment"||t.insideComment,level:(t.level||0)+1},v=c=>c===""?[]:t.indentStr&&c.includes(`
`)&&!c.includes("<")?c.split(`
`).map(p=>[f.level,p]):[[f.level,c]];let d,h;if(G(a)){if(!T(a.$bind,"$bind",o))return"";const c=g(n,a.$bind,[],o),{$bind:p,$children:I=[],...L}=a;if(!Array.isArray(c)){if(c!=null&&typeof c!="object")return o.error(`$bind resolved to primitive value of type "${typeof c}", cannot render children`),"";const S=c&&typeof c=="object"&&c!==null?c:{},j=[...s,n];return $({[r]:{...L,$children:I}},S,{...t,parents:j})}if(d=[],!b.has(r))for(const S of c){const j=[...s,n];for(const U of I){const z=$(U,S,{...f,parents:j});d.push(...v(z))}}h=L}else{if(d=[],!b.has(r))for(const c of l){const p=$(c,n,{...f,parents:s});d.push(...v(p))}h=u}return F(r,h,n,d,o,t.indentStr,t.level,s)}function Y(e,n,t,s=[],o){const i=Object.entries(e).filter(([r])=>N(r,t,o)).map(([r,a])=>{if(_(a)){const l=q(a,n,s,o);return`${r}="${A(w(String(l),n,!1,s,o))}"`}else return`${r}="${A(w(String(a),n,!1,s,o))}"`}).join(" ");return i?" "+i:""}function J(e,n={}){const{data:t={},yaml:s,indent:o,logger:i}=n,r=e.renderer.rules.fence;e.renderer.rules.fence=function(a,l,u,f,v){const d=a[l],h=d.info?d.info.trim():"";if(h==="treebark"||h.startsWith("treebark "))try{return K(d.content,t,s,o,i)+`
`}catch(c){const p=c instanceof Error?c.message:"Unknown error";return`<div class="treebark-error"><strong>Treebark Error:</strong> ${H(p)}</div>
`}return r?r(a,l,u,f,v):""}}function K(e,n,t,s,o){let i,r=null;if(!e.trim())throw new Error("Empty or invalid template");if(t)try{i=t.load(e)}catch(l){r=l instanceof Error?l:new Error("YAML parsing failed")}if(!i)try{i=JSON.parse(e)}catch(l){throw t&&r?new Error(`Failed to parse as YAML or JSON. YAML error: ${r.message}`):new Error(`Failed to parse as JSON: ${l instanceof Error?l.message:"Invalid format"}`)}if(!i)throw new Error("Empty or invalid template");const a={indent:s,logger:o};if(i&&typeof i=="object"&&"template"in i){const l={...n,...i.data};return R({template:i.template,data:l},a)}else return R({template:i,data:n},a)}function H(e){const n={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"};return e.replace(/[&<>"']/g,t=>n[t])}return J}));
//# sourceMappingURL=markdown-it-treebark-browser.min.js.map
