(function(p,y){typeof exports=="object"&&typeof module<"u"?module.exports=y():typeof define=="function"&&define.amd?define(y):(p=typeof globalThis<"u"?globalThis:p||self,p.MarkdownItTreebark=y())})(this,(function(){"use strict";const p=new Set(["div","span","p","header","footer","main","section","article","h1","h2","h3","h4","h5","h6","strong","em","blockquote","code","pre","ul","ol","li","table","thead","tbody","tr","th","td","a"]),y=new Set(["$comment","$if"]),b=new Set(["img","br","hr"]),P=new Set([...p,...y,...b]),E=new Set(["id","class","style","title","role","data-","aria-"]),W={a:new Set(["href","target","rel"]),img:new Set(["src","alt","width","height"]),table:new Set(["summary"]),th:new Set(["scope","colspan","rowspan"]),td:new Set(["scope","colspan","rowspan"]),blockquote:new Set(["cite"])},O=new Set(["$<","$>","$<=","$>=","$=","$in"]),C=new Set(["$check","$then","$else","$not","$join",...O]);function A(e,n,i=[]){if(n===".")return e;let o=e,s=n;for(;s.startsWith("..");){let t=0,r=s;for(;r.startsWith("..");)t++,r=r.substring(2),r.startsWith("/")&&(r=r.substring(1));if(t<=i.length)o=i[i.length-t],s=r.startsWith(".")?r.substring(1):r;else return}return s?s.split(".").reduce((t,r)=>t&&typeof t=="object"&&t!==null?t[r]:void 0,o):o}function v(e){return e.replace(/[&<>"']/g,n=>({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"})[n]||n)}function w(e,n,i=!0,o=[]){return e.replace(/\{\{\{([^{]*?)\}\}\}|\{\{([^{]*?)\}\}/g,(s,t,r)=>{if(t!==void 0)return`{{${t.trim()}}}`;const a=r.trim(),c=A(n,a,o);return c==null?"":i?v(String(c)):String(c)})}function N(e,n,i){const o=E.has(e)||[...E].some(r=>r.endsWith("-")&&e.startsWith(r)),s=W[n],t=s&&s.has(e);return!o&&!t?(i.warn(`Attribute "${e}" is not allowed on tag "${n}"`),!1):!0}function G(e){return e!==null&&typeof e=="object"&&!Array.isArray(e)&&"$bind"in e}function T(e,n,i){return e==="."?!0:e.includes("..")?(i.error(`${n} does not support parent context access (..) - use interpolation {{..prop}} in content/attributes instead. Invalid: ${n}: "${e}"`),!1):e.includes("{{")?(i.error(`${n} does not support interpolation {{...}} - use literal property paths only. Invalid: ${n}: "${e}"`),!1):!0}function k(e,n){const i=[];for(const r of O)r in n&&i.push({key:r,value:n[r]});if(i.length===0){const r=!!e;return n.$not?!r:r}const o=i.map(r=>{switch(r.key){case"$<":return typeof e=="number"&&typeof r.value=="number"&&e<r.value;case"$>":return typeof e=="number"&&typeof r.value=="number"&&e>r.value;case"$<=":return typeof e=="number"&&typeof r.value=="number"&&e<=r.value;case"$>=":return typeof e=="number"&&typeof r.value=="number"&&e>=r.value;case"$=":return e===r.value;case"$in":return Array.isArray(r.value)&&r.value.includes(e);default:return!1}}),s=n.$join==="OR";let t;return s?t=o.some(r=>r):t=o.every(r=>r),n.$not?!t:t}function _(e){return e!==null&&typeof e=="object"&&!Array.isArray(e)&&"$check"in e&&typeof e.$check=="string"}function q(e,n,i=[],o){if(!T(e.$check,"$check",o))return"";const s=A(n,e.$check,i);return k(s,e)?e.$then!==void 0?e.$then:"":e.$else!==void 0?e.$else:""}function M(e,n){if(!e||typeof e!="object"){n.error("Template object cannot be null, undefined, or non-object");return}const i=Object.entries(e);if(i.length===0){n.error("Template object must have at least one tag");return}const o=i[0];if(!o){n.error("Template object must have at least one tag");return}const[s,t]=o,r=typeof t=="string"?[t]:Array.isArray(t)?t:t?.$children||[],a=t&&typeof t=="object"&&!Array.isArray(t)?Object.fromEntries(Object.entries(t).filter(([c])=>c!=="$children")):{};return{tag:s,rest:t,children:r,attrs:a}}function B(e,n,i=[],o){const s=e;if(!s.$check)return o.error('"$if" tag requires $check attribute to specify the condition'),{valueToRender:void 0};if(!T(s.$check,"$check",o))return{valueToRender:void 0};const t=A(n,s.$check,i);typeof e=="object"&&e!==null&&!Array.isArray(e)&&"$children"in e&&o.warn('"$if" tag does not support $children, use $then and $else instead');const{$then:r,$else:a}=s;if(r!==void 0&&Array.isArray(r))return o.error('"$if" tag $then must be a string or single element object, not an array'),{valueToRender:void 0};if(a!==void 0&&Array.isArray(a))return o.error('"$if" tag $else must be a string or single element object, not an array'),{valueToRender:void 0};const f=(typeof e=="object"&&e!==null&&!Array.isArray(e)?Object.keys(e):[]).filter(u=>!C.has(u));return f.length>0&&o.warn(`"$if" tag does not support attributes: ${f.join(", ")}. Allowed: ${[...C].join(", ")}`),{valueToRender:k(t,s)?r:a}}const D=(e,n)=>{if(!n)return e.length<=1?e[0]?.[1]??"":e.reduce((o,[,s])=>o+s,"");if(e.length===0)return"";if(e.length===1&&!e[0][1].includes("<"))return e[0][1];let i=`
`;for(let o=0;o<e.length;o++)i+=n.repeat(e[o][0])+e[o][1],o<e.length-1&&(i+=`
`);return i+=`
`,i};function R(e,n={}){const i=e.data||{},o=n.logger||console,s=n.indent?{indentStr:typeof n.indent=="number"?" ".repeat(n.indent):typeof n.indent=="string"?n.indent:"  ",level:0,logger:o}:{logger:o};return $(e.template,i,s)}function F(e,n,i,o,s,t,r,a=[]){const c=D(o,t),f=c.startsWith(`
`)&&t?t.repeat(r||0):"";if(e==="$comment")return`<!--${c}${f}-->`;const d=`<${e}${Y(n,i,e,a,s)}>`;return b.has(e)?d:`${d}${c}${f}</${e}>`}function $(e,n,i){const o=i.parents||[],s=i.logger;if(typeof e=="string")return w(e,n,!0,o);if(Array.isArray(e))return e.map(l=>$(l,n,i)).join(i.indentStr?`
`:"");const t=M(e,s);if(!t)return"";const{tag:r,rest:a,children:c,attrs:f}=t;if(!P.has(r))return s.error(`Tag "${r}" is not allowed`),"";if(r==="$comment"&&i.insideComment)return s.error("Nested comments are not allowed"),"";if(r==="$if"){const{valueToRender:l}=B(a,n,o,s);return l===void 0?"":$(l,n,i)}b.has(r)&&c.length>0&&s.warn(`Tag "${r}" is a void element and cannot have children`);const d={...i,insideComment:r==="$comment"||i.insideComment,level:(i.level||0)+1},g=l=>l===""?[]:i.indentStr&&l.includes(`
`)&&!l.includes("<")?l.split(`
`).map(m=>[d.level,m]):[[d.level,l]];let u,h;if(G(a)){if(!T(a.$bind,"$bind",s))return"";const l=A(n,a.$bind,[]),{$bind:m,$children:I=[],...L}=a;if(!Array.isArray(l)){const S=l&&typeof l=="object"&&l!==null?l:{},j=[...o,n];return $({[r]:{...L,$children:I}},S,{...i,parents:j})}if(u=[],!b.has(r))for(const S of l){const j=[...o,n];for(const U of I){const z=$(U,S,{...d,parents:j});u.push(...g(z))}}h=L}else{if(u=[],!b.has(r))for(const l of c){const m=$(l,n,{...d,parents:o});u.push(...g(m))}h=f}return F(r,h,n,u,s,i.indentStr,i.level,o)}function Y(e,n,i,o=[],s){const t=Object.entries(e).filter(([r])=>N(r,i,s)).map(([r,a])=>{if(_(a)){const c=q(a,n,o,s);return`${r}="${v(w(String(c),n,!1,o))}"`}else return`${r}="${v(w(String(a),n,!1,o))}"`}).join(" ");return t?" "+t:""}function J(e,n={}){const{data:i={},yaml:o,indent:s,logger:t}=n,r=e.renderer.rules.fence;e.renderer.rules.fence=function(a,c,f,d,g){const u=a[c],h=u.info?u.info.trim():"";if(h==="treebark"||h.startsWith("treebark "))try{return K(u.content,i,o,s,t)+`
`}catch(l){const m=l instanceof Error?l.message:"Unknown error";return`<div class="treebark-error"><strong>Treebark Error:</strong> ${H(m)}</div>
`}return r?r(a,c,f,d,g):""}}function K(e,n,i,o,s){let t,r=null;if(!e.trim())throw new Error("Empty or invalid template");if(i)try{t=i.load(e)}catch(c){r=c instanceof Error?c:new Error("YAML parsing failed")}if(!t)try{t=JSON.parse(e)}catch(c){throw i&&r?new Error(`Failed to parse as YAML or JSON. YAML error: ${r.message}`):new Error(`Failed to parse as JSON: ${c instanceof Error?c.message:"Invalid format"}`)}if(!t)throw new Error("Empty or invalid template");const a={indent:o};if(s&&(a.logger=s),t&&typeof t=="object"&&"template"in t){const c={...n,...t.data};return R({template:t.template,data:c},a)}else return R({template:t,data:n},a)}function H(e){const n={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"};return e.replace(/[&<>"']/g,i=>n[i])}return J}));
//# sourceMappingURL=markdown-it-treebark-browser.min.js.map
