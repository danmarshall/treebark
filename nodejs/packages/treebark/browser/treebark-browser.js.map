{"version":3,"file":"treebark-browser.js","sources":["../src/common.ts","../src/string.ts"],"sourcesContent":["// Common types, constants, and utilities shared between string and DOM renderers\nexport type Data = Record<string, unknown>;\n\n// Non-recursive template structure types (using $ prefixes for internal differentiation)\n// Template attributes defined first to avoid circular references\nexport type TemplateAttributes = {\n  $bind?: string;\n  $children?: (string | TemplateObject)[];\n  [key: string]: unknown;\n};\n\n// Template object maps tag names to content (no circular reference to TemplateElement)\nexport type TemplateObject = { [tag: string]: string | (string | TemplateObject)[] | TemplateAttributes };\n\n// Template element is either a string or an object (defined after TemplateObject)\nexport type TemplateElement = string | TemplateObject;\n\n// API input types (clean external interface without $ prefixes)\nexport interface TreebarkInput {\n  template: TemplateElement | TemplateElement[];\n  data?: Data;\n}\n\n// Options interface for render functions\nexport interface RenderOptions {\n  data?: Data;\n  indent?: string | number | boolean;\n}\n\n// Container tags that can have children and require closing tags\nexport const CONTAINER_TAGS = new Set([\n  'div', 'span', 'p', 'header', 'footer', 'main', 'section', 'article',\n  'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'strong', 'em', 'blockquote', 'code', 'pre',\n  'ul', 'ol', 'li',\n  'table', 'thead', 'tbody', 'tr', 'th', 'td',\n  'a',\n  'comment'\n]);\n\n// Void tags that cannot have children and are self-closing\nexport const VOID_TAGS = new Set([\n  'img'\n]);\n\n// All allowed tags (union of container and void tags)\nexport const ALLOWED_TAGS = new Set([...CONTAINER_TAGS, ...VOID_TAGS]);\n\n// Global attributes allowed on all tags\nexport const GLOBAL_ATTRS = new Set(['id', 'class', 'style', 'title', 'role', 'data-', 'aria-']);\n\n// Tag-specific attributes\nexport const TAG_SPECIFIC_ATTRS: Record<string, Set<string>> = {\n  'a': new Set(['href', 'target', 'rel']),\n  'img': new Set(['src', 'alt', 'width', 'height']),\n  'table': new Set(['summary']),\n  'th': new Set(['scope', 'colspan', 'rowspan']),\n  'td': new Set(['scope', 'colspan', 'rowspan']),\n  'blockquote': new Set(['cite'])\n};\n\n/**\n * Get a nested property from an object using dot notation\n */\nexport function getProperty(obj: Data, path: string): unknown {\n  return path.split('.').reduce((o: unknown, k: string): unknown => \n    (o && typeof o === 'object' && o !== null ? (o as Record<string, unknown>)[k] : undefined), obj);\n}\n\n/**\n * HTML escape function for template interpolation\n */\nexport function escape(s: string): string {\n  return s.replace(/[&<>\"']/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '\"': '&quot;', \"'\": '&#39;' })[c] || c);\n}\n\n/**\n * Interpolate template variables in a string\n */\nexport function interpolate(tpl: string, data: Data, escapeHtml = true): string {\n  return tpl.replace(/(\\{\\{\\{|\\{\\{)(.*?)(\\}\\}\\}|\\}\\})/g, (_, open, expr, close) => {\n    const trimmed = expr.trim();\n    if (open === '{{{') return `{{${trimmed}}}`;\n    const val = getProperty(data, trimmed);\n    return val == null ? \"\" : (escapeHtml ? escape(String(val)) : String(val));\n  });\n}\n\n\n/**\n * Validate that an attribute is allowed for the given tag\n */\nexport function validateAttribute(key: string, tag: string): void {\n  // Check global attributes first\n  const isGlobal = GLOBAL_ATTRS.has(key) || [...GLOBAL_ATTRS].some(p => p.endsWith('-') && key.startsWith(p));\n  \n  // Check tag-specific attributes\n  const tagAttrs = TAG_SPECIFIC_ATTRS[tag];\n  const isTagSpecific = tagAttrs && tagAttrs.has(key);\n  \n  if (!isGlobal && !isTagSpecific) {\n    throw new Error(`Attribute \"${key}\" is not allowed on tag \"${tag}\"`);\n  }\n}\n\n/**\n * Check if input is a TreebarkInput object\n */\nexport function isTreebarkInput(input: unknown): input is TreebarkInput {\n  return input !== null && typeof input === 'object' && 'template' in input;\n}\n\n/**\n * Check if a template object has a binding structure\n */\nexport function hasBinding(rest: string | (string | TemplateObject)[] | TemplateAttributes): rest is TemplateAttributes & { $bind: string } {\n  return rest !== null && typeof rest === 'object' && !Array.isArray(rest) && '$bind' in rest;\n}\n\n/**\n * Parse template object structure to extract tag, attributes, and children\n */\nexport function parseTemplateObject(templateObj: TemplateObject): {\n  tag: string;\n  rest: string | (string | TemplateObject)[] | TemplateAttributes;\n  children: (string | TemplateObject)[];\n  attrs: Record<string, unknown>;\n} {\n  const entries = Object.entries(templateObj);\n  if (entries.length === 0) {\n    throw new Error('Template object must have at least one tag');\n  }\n  const firstEntry = entries[0];\n  if (!firstEntry) {\n    throw new Error('Template object must have at least one tag');\n  }\n  const [tag, rest] = firstEntry;\n  \n  const children = typeof rest === 'string' ? [rest] : Array.isArray(rest) ? rest : (rest as TemplateAttributes)?.$children || [];\n  const attrs = rest && typeof rest === \"object\" && !Array.isArray(rest) \n    ? Object.fromEntries(Object.entries(rest).filter(([k]) => k !== '$children')) : {};\n    \n  return { tag, rest, children, attrs };\n}","import { \n  TemplateElement,\n  TemplateObject,\n  TreebarkInput,\n  Data, \n  ALLOWED_TAGS, \n  VOID_TAGS,\n  getProperty, \n  interpolate,\n  escape,\n  validateAttribute, \n  hasBinding, \n  parseTemplateObject,\n  RenderOptions\n} from './common';\n\nexport function renderToString(\n  input: TreebarkInput, \n  options: RenderOptions = {}\n): string {\n  const data = { ...input.data, ...options.data };\n  \n  // Conditionally set indent context\n  const context = options.indent ? {\n    indentStr: typeof options.indent === 'number' ? ' '.repeat(options.indent) :\n               typeof options.indent === 'string' ? options.indent : '  ',\n    level: 0\n  } : {};\n  \n  // If template is a single element and data is an array, render template for each data item\n  if (!Array.isArray(input.template) && Array.isArray(input.data)) {\n    const separator = context.indentStr ? '\\n' : '';\n    return input.data.map(item => \n      render(input.template, { ...item, ...options.data }, context)\n    ).join(separator);\n  }\n  \n  return render(input.template, data, context);\n}\n\n// Helper function to render tag, deciding internally whether to close or not\nfunction renderTag(tag: string, attrs: Record<string, unknown>, data: Data, content?: string, indentStr?: string, level?: number): string {\n  // Special handling for comment tags\n  if (tag === 'comment') {\n    return `<!--${content || \"\"}-->`;\n  }\n  \n  const openTag = `<${tag}${renderAttrs(attrs, data, tag)}>`;\n  const isVoid = VOID_TAGS.has(tag);\n  \n  // Void tags are never closed, regardless of content\n  if (isVoid) {\n    return openTag;\n  }\n  \n  // Apply indentation if enabled and content has child elements\n  if (indentStr && content && content.includes('<')) {\n    const currentIndent = indentStr.repeat(level || 0);\n    return `${openTag}\\n${content}\\n${currentIndent}</${tag}>`;\n  }\n  \n  // Non-void tags get content (even if empty) and closing tag\n  return `${openTag}${content || \"\"}</${tag}>`;\n}\n\nfunction render(template: TemplateElement | TemplateElement[], data: Data, context: { insideComment?: boolean; indentStr?: string; level?: number } = {}): string {\n  if (typeof template === \"string\") return interpolate(template, data);\n  \n  const separator = context.indentStr ? '\\n' : '';\n  \n  if (Array.isArray(template)) {\n    return template.map(t => render(t, data, context)).join(separator);\n  }\n  \n  const { tag, rest, children, attrs } = parseTemplateObject(template);\n  \n  // Inline validateTag: Validate that a tag is allowed\n  if (!ALLOWED_TAGS.has(tag)) {\n    throw new Error(`Tag \"${tag}\" is not allowed`);\n  }\n  \n  // Prevent nested comments\n  if (tag === 'comment' && context.insideComment) {\n    throw new Error('Nested comments are not allowed');\n  }\n  \n  // Inline validateChildren: Validate that void tags don't have children\n  const hasChildren = children.length > 0;\n  const isVoid = VOID_TAGS.has(tag);\n  if (isVoid && hasChildren) {\n    throw new Error(`Tag \"${tag}\" is a void element and cannot have children`);\n  }\n  \n  // Prepare child context with incremented level\n  const childContext = { \n    ...context, \n    insideComment: tag === 'comment' || context.insideComment,\n    level: (context.level || 0) + 1\n  };\n  \n  // Handle $bind\n  if (hasBinding(rest)) {\n    const bound = getProperty(data, rest.$bind);\n    const { $bind, $children = [], ...bindAttrs } = rest;\n    \n    // Validate children for bound elements\n    if (isVoid && $children.length > 0) {\n      throw new Error(`Tag \"${tag}\" is a void element and cannot have children`);\n    }\n    \n    if (Array.isArray(bound)) {\n      const content = bound.map(item => \n        $children.map((c: string | TemplateObject) => {\n          const result = render(c, item as Data, childContext);\n          // Add indentation to child tags for bound arrays\n          if (context.indentStr && result.startsWith('<')) {\n            return context.indentStr.repeat(childContext.level) + result;\n          }\n          return result;\n        }).join(separator)\n      ).join(separator);\n      \n      return renderTag(tag, bindAttrs, data, content, context.indentStr, context.level);\n    }\n    \n    // For object binding, bound should be a Data object\n    const boundData = bound && typeof bound === 'object' && bound !== null ? bound as Data : {};\n    return render({ [tag]: { ...bindAttrs, $children } }, boundData, context);\n  }\n  \n  // Render children with indentation\n  const content = children.map((c: string | TemplateObject) => {\n    const result = render(c, data, childContext);\n    // Add indentation to child tags\n    if (context.indentStr && result.startsWith('<')) {\n      return context.indentStr.repeat(childContext.level) + result;\n    }\n    return result;\n  }).join(separator);\n  \n  return renderTag(tag, attrs, data, content, context.indentStr, context.level);\n}\n\nfunction renderAttrs(attrs: Record<string, unknown>, data: Data, tag: string): string {\n  const pairs = Object.entries(attrs).filter(([key]) => {\n    validateAttribute(key, tag);\n    return true;\n  }).map(([k, v]) => `${k}=\"${escape(interpolate(String(v), data, false))}\"`).join(\" \");\n  return pairs ? \" \" + pairs : \"\";\n}"],"names":["content"],"mappings":"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"}